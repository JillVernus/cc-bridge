// English locale
export default {
  // Common
  common: {
    save: 'Save',
    cancel: 'Cancel',
    delete: 'Delete',
    edit: 'Edit',
    add: 'Add',
    close: 'Close',
    confirm: 'Confirm',
    refresh: 'Refresh',
    loading: 'Loading...',
    noData: 'No data',
    settings: 'Settings',
    total: 'Total',
    enabled: 'Enabled',
    disabled: 'Disabled',
    success: 'Success',
    error: 'Error',
    warning: 'Warning',
    info: 'Info',
    unknown: 'Unknown',
    copy: 'Copy',
    copied: 'Copied!',
    required: 'Required',
    optional: 'Optional',
  },

  // Confirmation dialogs
  confirm: {
    deleteChannel: 'Delete Channel',
    deleteApiKey: 'Delete API Key',
  },

  // App
  app: {
    title: 'CC-Bridge Management',
    verifyingAccess: 'Verifying Access',
    authenticatingWithSavedKey: 'Authenticating with saved access key...',
    pricingSettings: 'Pricing Settings',
    rateLimitSettings: 'Rate Limit Settings',
    debugLogSettings: 'Debug Log Settings',
    failoverSettings: 'Failover Settings',
    logout: 'Logout',
    loggedOut: 'Logged out safely',
  },

  // Auth
  auth: {
    accessKey: 'Access Key (PROXY_ACCESS_KEY)',
    enterAccessKey: 'Please enter access key',
    accessManagement: 'Access Management',
    securityTips: 'Security Tips:',
    tip1: 'Access key is set in server\'s PROXY_ACCESS_KEY environment variable',
    tip2: 'Key will be saved locally for automatic login next time',
    tip3: 'Do not share your access key with others',
    tip4: 'If key is compromised, change server configuration immediately',
    tip5: '{count} consecutive auth failures will lock for 5 minutes',
    authFailed: 'Access key verification failed (remaining attempts: {remaining})',
    tooManyAttempts: 'Too many auth attempts, please try again in 5 minutes',
    waitAndRetry: 'Too many auth attempts, please try again in {seconds} seconds',
    savedKeyInvalid: 'Saved access key is invalid, please re-enter',
    enterKeyToContinue: 'Please enter access key to continue',
  },

  // Stats
  stats: {
    totalChannels: 'Total Channels',
    configuredChannels: 'Configured API channels',
    activeChannels: 'Active Channels',
    failoverScheduling: 'In failover scheduling',
    systemStatus: 'System Status',
    running: 'Running',
    serviceNormal: 'Service running normally',
  },

  // Actions
  actions: {
    addChannel: 'Add Channel',
    testLatency: 'Test Latency',
    addFirstChannel: 'Add First Channel',
  },

  // Load Balance
  loadBalance: {
    title: 'API Key Distribution Strategy',
    roundRobin: 'Round Robin',
    roundRobinDesc: 'Use API keys in sequence',
    random: 'Random',
    randomDesc: 'Randomly select API key',
    failover: 'Failover',
    failoverDesc: 'Use first, switch on failure',
    updated: 'Load balance strategy updated to: {strategy}',
    updateFailed: 'Failed to update load balance strategy: {error}',
  },

  // Channel
  channel: {
    noChannels: 'No Channels Configured',
    noChannelsDesc: 'No API channels configured yet, add your first channel to start using the proxy service',
    addApiKey: 'Add API Key',
    apiKeyLabel: 'API Key',
    enterApiKey: 'Enter API key',
    updateSuccess: 'Channel updated successfully',
    addSuccess: 'Channel added successfully',
    deleteSuccess: 'Channel deleted successfully',
    deleteConfirm: 'Are you sure you want to delete this channel?',
    apiKeyAddSuccess: 'API key added successfully',
    apiKeyAddFailed: 'Failed to add API key: {error}',
    apiKeyDeleteSuccess: 'API key deleted successfully',
    apiKeyDeleteFailed: 'Failed to delete API key: {error}',
    apiKeyDeleteConfirm: 'Are you sure you want to delete this API key?',
    latencyTestComplete: 'Latency test complete: {latency}ms',
    latencyTestFailed: 'Latency test failed: {error}',
    allLatencyTestComplete: 'All channel latency tests complete',
    batchLatencyTestFailed: 'Batch latency test failed: {error}',
    prioritySet: 'Channel {name} set to highest priority for 5 minutes',
    prioritySetFailed: 'Failed to set quick add priority',
  },

  // Channel Orchestration
  orchestration: {
    title: 'Channel Orchestration',
    multiChannelMode: 'Multi-channel Mode',
    singleChannelMode: 'Single-channel Mode',
    failoverSequence: 'Failover Sequence',
    dragToReorder: 'Drag to reorder, auto-saves',
    noActiveChannels: 'No active channels',
    enableFromPool: 'Enable channels from reserve pool below',
    reservePool: 'Reserve Pool',
    enableToAppend: 'Enabled channels will be appended to active sequence',
    allActive: 'All channels are active',
    openWebsite: 'Open website',
    requests: 'requests',
    requestStats: 'Request Statistics',
    minutes15: '15 minutes:',
    hour1: '1 hour:',
    hours6: '6 hours:',
    hours24: '24 hours:',
    pause: 'Pause',
    resume: 'Resume',
    resumeReset: 'Resume (reset metrics)',
    moveToPool: 'Move to reserve',
    boostPriority: 'Boost priority (5min)',
    keepAtLeastOne: '(keep at least one)',
    cannotDelete: 'Cannot delete: at least one active channel required in failover sequence',
    saveOrderFailed: 'Failed to save channel order: {error}',
    setStatusFailed: 'Failed to set channel status: {error}',
    setPriorityFailed: 'Failed to set priority: {error}',
    quotaRemaining: 'remaining',
    clickForDetails: 'Click for details',
  },

  // Channel Status
  status: {
    active: 'Active',
    healthy: 'Healthy',
    suspended: 'Suspended',
    disabled: 'Disabled',
    error: 'Error',
    unknown: 'Unknown',
    undetected: 'Undetected',
    requestCount: 'Requests',
    successRate: 'Success Rate',
    consecutiveFailures: 'Consecutive Failures',
    lastSuccess: 'Last Success',
    lastFailure: 'Last Failure',
    noMetrics: 'No metrics data',
    justNow: 'Just now',
    minutesAgo: '{count} min ago',
    hoursAgo: '{count} hours ago',
    connectionNormal: 'Connection normal: last check passed',
    connectionError: 'Connection error: check base URL, network, or API key',
    notDetected: 'Not detected: click "Test Latency" to check',
  },

  // Add Channel Modal
  addChannel: {
    addTitle: 'Add New Channel',
    editTitle: 'Edit Channel',
    editSubtitle: 'Modify channel configuration',
    addSubtitle: 'Configure API channel info and keys',
    quickAddSubtitle: 'Quickly batch add API keys',
    detailedConfig: 'Detailed Config',
    quickAdd: 'Quick Add',
    inputContent: 'Input Content',
    inputPlaceholder: 'Enter one API Key or Base URL per line\n\nExample:\nsk-xxx-your-api-key\nsk-yyy-another-key\nhttps://api.example.com/v1',
    baseUrlDetected: 'Detected',
    baseUrlRequired: 'Please enter a valid URL (https://...)',
    apiKeysLabel: 'API Keys',
    keysDetected: '{count} keys detected',
    atLeastOneKey: 'Please enter at least one API Key',
    keysCount: '{count}',
    channelName: 'Channel Name',
    autoGenerated: 'Auto-generated',
    channelType: 'Channel Type',
    responsesType: 'Responses (Codex)',
    messagesType: 'Claude (Messages)',
    channelNameLabel: 'Channel Name *',
    channelNamePlaceholder: 'e.g., GPT-4 Channel',
    serviceType: 'Service Type *',
    serviceTypeResponses: 'Responses (Native API)',
    serviceTypeOpenAI: 'OpenAI (New API)',
    serviceTypeOpenAIChat: 'OPENAI (Chat)',
    serviceTypeOpenAIOld: 'OpenAI (Legacy Compatible)',
    serviceTypeClaude: 'Claude',
    serviceTypeGemini: 'Gemini',
    baseUrl: 'Base URL *',
    baseUrlPlaceholder: 'e.g., https://api.openai.com/v1',
    urlHintOpenAI: 'Usually: https://api.openai.com/v1',
    urlHintClaude: 'Usually: https://api.anthropic.com',
    urlHintGemini: 'Usually: https://generativelanguage.googleapis.com/v1',
    urlHintDefault: 'Enter complete API base URL',
    websiteLabel: 'Website/Console (optional)',
    websitePlaceholder: 'e.g., https://platform.openai.com',
    skipTlsVerify: 'Skip TLS Certificate Verification',
    skipTlsVerifyHint: 'Only enable temporarily for self-signed or domain mismatch',
    responseTimeout: 'Response Header Timeout (sec)',
    responseTimeoutHint: 'Max wait time for upstream to start responding, default 120s',
    description: 'Description (optional)',
    descriptionHint: 'Optional channel description...',
    modelRedirect: 'Model Redirect (optional)',
    autoConvertModel: 'Auto-convert model names',
    modelMappingHintResponses: 'Configure model name mapping to redirect request models. e.g., redirect "o3" to "gpt-5.1-codex-max"',
    modelMappingHintMessages: 'Configure model name mapping to redirect request models. e.g., redirect "opus" to "claude-3-5-sonnet"',
    sourceModel: 'Source Model',
    selectSourceModel: 'Select source model',
    targetModel: 'Target Model',
    targetModelPlaceholderResponses: 'e.g., gpt-5.1-codex-max',
    targetModelPlaceholderMessages: 'e.g., claude-3-5-sonnet',
    priceMultiplier: 'Price Multiplier (optional)',
    channelDiscount: 'Channel discount',
    priceMultiplierHint: 'Configure price multiplier for this channel. e.g., 0.8 = 80%, 0.5 = 50%. Use "_default" for all models, or specify model name (supports prefix matching).',
    modelNameDefault: 'Model name (or _default)',
    modelNamePlaceholder: 'claude-opus-4-5 or _default',
    inputMultiplier: 'Input multiplier',
    outputMultiplier: 'Output multiplier',
    cacheCreation: 'Cache creation',
    cacheRead: 'Cache read',
    defaultAllModels: 'Default (all models)',
    input: 'Input',
    output: 'Output',
    noDiscount: '(no discount)',
    apiKeyManagement: 'API Key Management *',
    atLeastOneKeyRequired: 'At least one key required',
    existingKeysInfo: '{count} existing key(s) configured (keys are write-only for security)',
    existingKeysLabel: 'Existing Keys ({count})',
    newKeysToAdd: 'New keys to add:',
    multiKeyLoadBalance: 'Add multiple keys for load balancing',
    addNewApiKey: 'Add new API key',
    enterFullApiKey: 'Enter full API key',
    duplicateKey: 'This key already exists',
    duplicateKeyBadge: 'Duplicate',
    moveToTop: 'Move to top',
    moveToBottom: 'Move to bottom',
    copyKey: 'Copy key',
    deleteKey: 'Delete key',
    createChannel: 'Create Channel',
    updateChannel: 'Update Channel',
    requiredField: 'This field is required',
    invalidUrl: 'Please enter a valid URL',
    // OAuth
    serviceTypeOpenAIOAuth: 'OpenAI OAuth (Codex)',
    oauthConfig: 'OAuth Authentication',
    oauthRequired: 'Required',
    oauthHint: 'Paste the content of auth.json from the official Codex CLI (~/.codex/auth.json). cc-bridge will automatically manage token refresh.',
    oauthJsonLabel: 'auth.json Content',
    oauthJsonPlaceholder: 'Paste the content of ~/.codex/auth.json here...',
    oauthJsonPath: 'File path',
    oauthConfigured: 'OAuth Configured',
    oauthMissingAccessToken: 'Missing access_token in JSON',
    oauthMissingAccountId: 'Missing account_id in JSON',
    oauthMissingRefreshToken: 'Missing refresh_token in JSON',
    oauthInvalidJson: 'Invalid JSON format',
    oauthFixedUrl: 'Fixed API endpoint',
    // Tabs
    configTab: 'Configuration',
    quotaTab: 'Quota',
  },

  // Request Log
  requestLog: {
    byModel: 'By Model',
    byChannel: 'By Channel',
    groupByModel: 'Model Name',
    groupByProvider: 'Provider (Upstream)',
    groupByClient: 'Client ID',
    groupBySession: 'Session ID',
    groupByApiKey: 'API Key',
    dateFilter: 'Date Filter',
    unitDay: 'Day',
    unitWeek: 'Week',
    unitMonth: 'Month',
    model: 'Model',
    channel: 'Channel',
    client: 'Client',
    session: 'Session',
    apiKey: 'API Key',
    clientId: 'Client ID',
    sessionId: 'Session ID',
    filters: 'Filters',
    clearFilters: 'Clear Filters',
    requests: 'Requests',
    input: 'Input',
    output: 'Output',
    cacheCreation: 'Cache',
    cacheHit: 'Hit',
    cacheHitRate: 'Hit%',
    cacheHitRateTooltip: 'Cache Hit Rate = Cache Read / (Input + Cache Read + Cache Creation) × 100%',
    cost: 'Cost',
    settings: 'Settings',
    columnVisibility: 'Column Visibility',
    showAllColumns: 'Show All',
    columnVisibilityDesc: 'Toggle columns to show or hide in the log table',
    columnWidthSettings: 'Column Width Settings',
    resetColumnWidth: 'Reset Column Width',
    resetColumnWidthDesc: 'Reset all column widths to default',
    retentionCleanup: 'Retention Cleanup',
    retentionCleanupDesc: 'Delete logs older than the selected retention period',
    retention30: '30 days',
    retention60: '60 days',
    retention90: '90 days',
    retention180: '180 days',
    retention365: '365 days',
    cleanup: 'Cleanup',
    confirmCleanup: 'Confirm Cleanup',
    confirmCleanupDesc: 'Delete all logs older than {days} days? This cannot be undone.',
    confirmCleanupBtn: 'Cleanup',
    cleanupComplete: 'Cleanup Complete',
    cleanupResultDesc: 'Deleted {count} records older than {days} days.',
    databaseOps: 'Database Operations',
    clearLogs: 'Clear Log Data',
    clearLogsDesc: 'Delete all request logs, this cannot be undone',
    confirmClear: 'Confirm Clear',
    confirmClearDesc: 'Are you sure you want to delete all log data? This cannot be undone.',
    confirmDelete: 'Confirm Delete',
    autoRefreshing: 'Auto-refreshing...',
    autoRefreshOff: 'Auto-refresh off',
    totalRecords: '{count} records total',
    status: 'Status',
    time: 'Time',
    duration: 'Duration',
    tokens: 'Tokens',
    price: 'Price',
    http: 'HTTP',
    pending: 'Pending',
    completed: 'Completed',
    timeout: 'Timeout',
    failover: 'Failover',
    error: 'Error',
    upstreamResponse: 'Upstream Response',
    reasoningEffort: 'Reasoning Effort:',
    costBreakdown: 'Cost Breakdown',
    inputCost: 'Input:',
    outputCost: 'Output:',
    cacheCreateCost: 'Cache Create:',
    cacheHitCost: 'Cache Hit:',
    totalCost: 'Total:',
    prevPage: 'Previous',
    nextPage: 'Next',
    activeSessions: 'Active Sessions',
    sessions: 'sessions',
    live: 'Live',
    noActiveSessions: 'No active sessions',
    // User alias
    alias: 'Alias',
    assignAlias: 'Assign Alias',
    aliasName: 'Alias Name',
    aliasPlaceholder: 'Enter a friendly name',
    removeAlias: 'Remove Alias',
    aliasNotUnique: 'This alias is already in use',
    userAliasManagement: 'User ID Aliases',
    userAliasDesc: 'Click on a User ID in the table to assign an alias. Aliases are stored on the server and synced across devices.',
    noAliases: 'No aliases defined. Click on a User ID in the logs table to add one.',
  },

  // Pricing Settings
  pricing: {
    title: 'Model Pricing Configuration',
    priceUnit: 'Set token prices per model (unit: $/1M tokens)',
    addModel: 'Add Model',
    resetDefault: 'Reset Default',
    inputPrice: 'Input Price',
    outputPrice: 'Output Price',
    cacheCreationPrice: 'Cache Creation',
    cacheReadPrice: 'Cache Read',
    operation: 'Actions',
    noPricingConfig: 'No pricing configuration',
    loadPricingFailed: 'Failed to load pricing configuration',
    addModelPricing: 'Add Model Pricing',
    editModelPricing: 'Edit Model Pricing',
    modelName: 'Model Name',
    modelNamePlaceholder: 'e.g., claude-3-5-sonnet',
    descriptionOptional: 'Description (optional)',
    modelDescription: 'Model description',
    inputPriceLabel: 'Input Price ($/1M)',
    outputPriceLabel: 'Output Price ($/1M)',
    cacheCreationLabel: 'Cache Creation Price ($/1M)',
    cacheCreationHint: 'Default: input price × 1.25',
    cacheReadLabel: 'Cache Read Price ($/1M)',
    cacheReadHint: 'Default: input price × 0.1',
    confirmDeleteModel: 'Are you sure you want to delete pricing for model "{model}"?',
    confirmReset: 'Confirm Reset',
    confirmResetDesc: 'Are you sure you want to reset all pricing to defaults? Custom prices will be lost.',
    duplicate: 'Duplicate',
  },

  // Backup & Restore
  backup: {
    title: 'Backup & Restore',
    createBackup: 'Create Backup',
    backupList: 'Available Backups',
    noBackups: 'No backups available',
    restore: 'Restore',
    confirmRestore: 'Confirm Restore',
    confirmRestoreDesc: 'Are you sure you want to restore this backup? Current configuration will be replaced.',
    createSuccess: 'Backup created successfully',
    createFailed: 'Failed to create backup',
    restoreSuccess: 'Configuration restored successfully',
    restoreFailed: 'Failed to restore configuration',
    deleteSuccess: 'Backup deleted',
    deleteFailed: 'Failed to delete backup',
    loadFailed: 'Failed to load backup list',
  },

  // Rate Limit Settings
  rateLimit: {
    title: 'Rate Limit Settings',
    apiSection: 'API Rate Limit',
    portalSection: 'Portal Rate Limit',
    authFailureSection: 'Auth Failure Protection',
    enabled: 'Enabled',
    requestsPerMinute: 'Requests/min',
    apiDescription: 'Rate limit for /v1/messages and /v1/responses endpoints',
    portalDescription: 'Rate limit for management portal /api/* endpoints',
    authFailureDescription: 'Block IPs after multiple authentication failures to prevent brute-force attacks',
    failures: 'Failures',
    blockMinutes: 'Block (min)',
    addThreshold: 'Add Threshold',
    resetDefault: 'Reset Default',
    confirmReset: 'Confirm Reset',
    confirmResetDesc: 'Are you sure you want to reset rate limit settings to defaults?',
    loadFailed: 'Failed to load rate limit configuration',
    saveFailed: 'Failed to save rate limit configuration',
    resetFailed: 'Failed to reset rate limit configuration',
    thresholdOrderError: 'Thresholds must be in ascending order by failure count',
    perKeyRateLimit: 'Rate Limit (RPM)',
    perKeyRateLimitHint: '0 = use global limit',
    useGlobal: 'Global',
  },

  // Language
  language: {
    en: 'English',
    zhCN: '简体中文',
  },

  // Charts
  chart: {
    duration: {
      '1h': '1h',
      '6h': '6h',
      '24h': '24h',
      today: 'Today',
      period: 'Period',
    },
    endpoint: {
      all: 'All',
      messages: 'Claude',
      responses: 'Codex',
    },
    view: {
      traffic: 'Traffic',
      tokens: 'Tokens',
      cache: 'Cache',
      latency: 'Latency',
      cost: 'Cost',
    },
    summary: {
      totalRequests: 'Total Requests',
      successRate: 'Success Rate',
      inputTokens: 'Input Tokens',
      outputTokens: 'Output Tokens',
      cacheCreate: 'Cache Create',
      cacheHit: 'Cache Hit',
      p50Latency: 'p50 Latency',
      p95Latency: 'p95 Latency',
      totalCost: 'Total Cost',
      avgCostPerRequest: 'Avg / Request',
    },
    legend: {
      totalRequests: 'Total Requests',
      success: 'Success',
      inputTokens: 'Input Tokens',
      outputTokens: 'Output Tokens',
      cacheCreate: 'Cache Create',
      cacheHit: 'Cache Hit',
      p50Latency: 'p50 Latency',
      p95Latency: 'p95 Latency',
    },
    unit: {
      requests: 'requests',
    },
    noData: 'No data for selected period',
    noDataChannel: 'No data for this channel',
    error: {
      fetchFailed: 'Failed to fetch chart data',
    },
  },

  // API Keys
  apiKeys: {
    tabTitle: 'Keys',
    title: 'API Key Management',
    create: 'Create Key',
    createTitle: 'Create API Key',
    editTitle: 'Edit API Key',
    name: 'Name',
    nameRequired: 'Name is required',
    description: 'Description',
    keyPrefix: 'Key',
    role: 'Role',
    admin: 'Admin',
    isAdmin: 'Admin privileges',
    isAdminHint: 'Admin keys can manage other API keys',
    rateLimit: 'Rate Limit',
    rateLimitRpm: 'Rate Limit (RPM)',
    rateLimitRpmHint: '0 = use global rate limit',
    rpm: 'rpm',
    useGlobal: 'Global',
    lastUsed: 'Last Used',
    createdAt: 'Created',
    actions: 'Actions',
    neverUsed: 'Never',
    status: {
      label: 'Status',
      active: 'Active',
      disabled: 'Disabled',
      revoked: 'Revoked',
    },
    edit: 'Edit',
    enable: 'Enable',
    disable: 'Disable',
    revoke: 'Revoke',
    delete: 'Delete',
    keyCreated: 'API Key Created',
    keyCreatedWarning: 'Copy this key now. You won\'t be able to see it again!',
    understood: 'I\'ve copied the key',
    keyCopied: 'Key copied to clipboard',
    copyError: 'Failed to copy key',
    confirmRevoke: 'Revoke API Key',
    revokeWarning: 'This action is permanent. A revoked key cannot be re-enabled.',
    revokeConfirmText: 'Are you sure you want to revoke the key "{name}"?',
    confirmDelete: 'Delete API Key',
    deleteConfirmText: 'Are you sure you want to delete the key "{name}"?',
    loadError: 'Failed to load API keys',
    createSuccess: 'API key created successfully',
    updateSuccess: 'API key updated successfully',
    saveError: 'Failed to save API key',
    enableSuccess: 'API key enabled',
    enableError: 'Failed to enable API key',
    disableSuccess: 'API key disabled',
    disableError: 'Failed to disable API key',
    revokeSuccess: 'API key revoked',
    revokeError: 'Failed to revoke API key',
    deleteSuccess: 'API key deleted',
    deleteError: 'Failed to delete API key',
    // Permissions
    permissions: 'Permissions',
    permissionsHint: 'Leave empty for unrestricted access',
    allowedEndpoints: 'Allowed Endpoints',
    allowedEndpointsHint: 'Select which API endpoints this key can access',
    endpointMessages: 'Messages API (/v1/messages)',
    endpointResponses: 'Responses API (/v1/responses)',
    allowedModels: 'Allowed Models',
    allowedModelsHint: 'Glob patterns (e.g., claude-sonnet-*, gpt-4*). One per line.',
    allowedChannelsMsg: 'Allowed Channels (Messages)',
    allowedChannelsMsgHint: 'Select channels this key can use for Messages API',
    allowedChannelsResp: 'Allowed Channels (Responses)',
    allowedChannelsRespHint: 'Select channels this key can use for Responses API',
    allChannels: 'All Channels',
    allModels: 'All Models',
    allEndpoints: 'All Endpoints',
    restrictedEndpoints: '{count} endpoint(s)',
    restrictedModels: '{count} pattern(s)',
    restrictedChannels: '{count} channel(s)',
  },

  // OAuth Status
  oauth: {
    status: 'OAuth Status',
    viewStatus: 'View OAuth Status',
    notConfigured: 'OAuth tokens not configured',
    configured: 'OAuth Configured',
    email: 'Email',
    accountId: 'Account ID',
    planType: 'Plan Type',
    subscriptionActiveUntil: 'Subscription Active Until',
    subscriptionLastChecked: 'Last Checked',
    tokenExpiry: 'Token Expires',
    lastRefresh: 'Last Refresh',
    tokenStatus: {
      valid: 'Valid',
      expiring_soon: 'Expiring Soon',
      expired: 'Expired',
    },
    expiresIn: 'Expires in {seconds}s',
    loadError: 'Failed to load OAuth status',
    notOAuthChannel: 'Not an OAuth channel',
    // Quota related
    usageQuota: 'Usage Quota',
    primaryWindow: 'Short-term',
    secondaryWindow: 'Long-term',
    availablePercent: '{percent}% available',
    rateLimits: 'Rate Limits',
    requestLimit: 'Requests',
    tokenLimit: 'Tokens',
    resetsAt: 'Resets at {time}',
    lastUpdated: 'Last updated: {time}',
    quotaExceeded: 'Quota Exceeded',
    recoversAt: 'Recovers at {time}',
    noQuotaData: 'No quota data available. Make a request to see usage.',
    accountDetails: 'Account Details',
    // Credits
    creditsUnlimited: 'Unlimited credits',
    creditsBalance: 'Credits: {balance}',
    creditsAvailable: 'Credits available',
  },

  // Quota (user-configured channel quotas)
  quota: {
    title: 'Quota Settings',
    description: 'Configure usage limits for this channel. Quotas are tracked for informational purposes and do not block requests when exceeded.',
    requestQuota: 'Request Quota',
    creditQuota: 'Credit Quota',
    used: 'Used',
    remaining: 'Remaining',
    limit: 'Limit',
    nextReset: 'Next reset',
    noData: 'No quota data',
    quotaType: 'Quota Type',
    quotaTypeNone: 'None',
    quotaTypeRequests: 'Request Count',
    quotaTypeCredit: 'Credit Amount',
    quotaLimit: 'Quota Limit',
    quotaLimitHint: 'Maximum allowed value for the quota period',
    resetConfig: 'Reset Configuration',
    firstResetAt: 'First Reset Time',
    firstResetAtHint: 'When the first quota reset will occur',
    resetInterval: 'Reset Interval',
    resetIntervalHint: 'How often the quota resets after the first reset',
    intervalUnit: {
      hours: 'Hours',
      days: 'Days',
      weeks: 'Weeks',
      months: 'Months',
    },
    manualReset: 'Reset Now',
    manualResetConfirm: 'Reset Quota',
    manualResetDesc: 'This will reset the used quota to 0. Continue?',
    resetSuccess: 'Quota reset successfully',
    resetFailed: 'Failed to reset quota',
    quotaModels: 'Model Filter',
    quotaModelsLabel: 'Model Patterns',
    quotaModelsPlaceholder: 'Type pattern and press Enter',
    quotaModelsHint: 'Only count quota for models matching these patterns (substring match). Leave empty for all models.',
    quotaModelsApplied: 'Models',
    resetMode: 'Reset Mode',
    resetModeFixed: 'Fixed Interval',
    resetModeRolling: 'Rolling Interval',
    resetModeFixedHint: 'Reset at fixed schedule based on first reset time',
    resetModeRollingHint: 'Reset interval starts from first request after each reset',
  },

  // Debug Log Settings
  debugLog: {
    title: 'Debug Log Settings',
    enabled: 'Enabled',
    disabled: 'Disabled',
    enableDescription: 'When enabled, full request and response bodies (headers + body) will be captured for debugging purposes.',
    retentionSection: 'Log Retention',
    retentionHours: 'Retention Hours',
    retentionDescription: 'Debug logs older than this will be automatically cleaned up.',
    maxSizeSection: 'Body Size Limit',
    maxBodySize: 'Max Body Size',
    maxSizeDescription: 'Request/response bodies larger than this will be truncated.',
    storedLogs: '{count} debug log entries stored',
    purgeAll: 'Purge All',
    confirmPurge: 'Purge Debug Logs',
    confirmPurgeDesc: 'Are you sure you want to delete all debug logs? This cannot be undone.',
    purged: 'Purged {count} debug log entries',
    purgeFailed: 'Failed to purge debug logs',
    loadFailed: 'Failed to load debug log configuration',
    saveFailed: 'Failed to save debug log configuration',
  },

  // Failover Settings
  failover: {
    title: 'Failover Threshold Settings',
    enabled: 'Enabled',
    disabled: 'Disabled',
    enableDescription: 'When enabled, failover occurs only after consecutive errors reach the configured threshold. When disabled, failover triggers immediately on any qualifying error.',
    rulesSection: 'Error Threshold Rules',
    rulesDescription: 'Define how many consecutive errors of each type are allowed before triggering failover to the next channel/key.',
    errorCodes: 'Error Codes',
    threshold: 'Threshold',
    codesPlaceholder: 'e.g. 401,403 or others',
    addRule: 'Add Rule',
    howItWorks: 'How it works:',
    howItWorksItem1: 'Error codes can be comma-separated (e.g., "401,403") or "others" for unmatched codes',
    howItWorksItem2: 'Threshold = consecutive errors needed before failover (1 = immediate)',
    howItWorksItem3: 'Counters reset on successful (2xx) responses',
    reset: 'Reset to Defaults',
    resetSuccess: 'Configuration reset to defaults',
    resetFailed: 'Failed to reset configuration',
    loadFailed: 'Failed to load failover configuration',
    saveFailed: 'Failed to save failover configuration',
    emptyCodesError: 'Error codes cannot be empty',
    invalidThresholdError: 'Threshold must be at least 1',
    // Error code reference tooltip
    errorCodeReference: 'Common HTTP Error Codes',
    errorCode401: 'Unauthorized (invalid API key)',
    errorCode403: 'Forbidden (permission denied)',
    errorCode429: 'Rate limit exceeded',
    errorCode500: 'Internal server error',
    errorCode502: 'Bad gateway',
    errorCode503: 'Service unavailable',
    errorCode504: 'Gateway timeout',
    errorCodeOthers: 'Any other error code',
  },

  // Debug Modal (for viewing request/response details)
  debugModal: {
    title: 'Request Debug Details',
    request: 'Request',
    response: 'Response',
    headers: 'Headers',
    body: 'Body',
    noHeaders: 'No headers captured',
    noData: 'No debug data available for this request',
    loadFailed: 'Failed to load debug data',
  },
}
